import { useState, useEffect } from 'react';
import { useAccount, useReadContract, useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { parseEther, formatEther } from 'viem';
import { VaultShieldABI } from '../lib/contracts';

// Contract address - this should be deployed and updated
const VAULT_SHIELD_ADDRESS = '0x0000000000000000000000000000000000000000'; // Update with deployed address

export interface VaultData {
  vaultId: number;
  nftTokenId: number;
  collateralValue: number;
  loanAmount: number;
  interestRate: number;
  liquidationThreshold: number;
  isActive: boolean;
  isLiquidated: boolean;
  owner: string;
  nftContract: string;
  createdAt: number;
  maturityDate: number;
}

export interface LoanRequestData {
  requestId: number;
  requestedAmount: number;
  nftValue: number;
  loanDuration: number;
  isApproved: boolean;
  isActive: boolean;
  borrower: string;
  nftContract: string;
  nftTokenId: number;
  createdAt: number;
}

export interface RepaymentData {
  repaymentId: number;
  amount: number;
  principalAmount: number;
  interestAmount: number;
  borrower: string;
  timestamp: number;
}

export function useVaultShield() {
  const { address, isConnected } = useAccount();
  const { writeContract, data: hash, error: writeError, isPending } = useWriteContract();
  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
    hash,
  });
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [transactionStatus, setTransactionStatus] = useState<'idle' | 'pending' | 'confirming' | 'success' | 'error'>('idle');

  // Update transaction status based on contract interaction state
  useEffect(() => {
    if (isPending) {
      setTransactionStatus('pending');
    } else if (isConfirming) {
      setTransactionStatus('confirming');
    } else if (isConfirmed) {
      setTransactionStatus('success');
    } else if (writeError) {
      setTransactionStatus('error');
      setError(writeError.message);
    }
  }, [isPending, isConfirming, isConfirmed, writeError]);

  // Read contract functions
  const { data: vaultInfo } = useReadContract({
    address: VAULT_SHIELD_ADDRESS,
    abi: VaultShieldABI,
    functionName: 'getVaultInfo',
    args: [0], // vaultId
  });

  const { data: borrowerReputation } = useReadContract({
    address: VAULT_SHIELD_ADDRESS,
    abi: VaultShieldABI,
    functionName: 'getBorrowerReputation',
    args: address ? [address] : undefined,
  });

  const { data: totalBorrowed } = useReadContract({
    address: VAULT_SHIELD_ADDRESS,
    abi: VaultShieldABI,
    functionName: 'getTotalBorrowed',
    args: address ? [address] : undefined,
  });

  // FHE encryption helper function (placeholder for real FHE implementation)
  const encryptValue = (value: number): string => {
    // In real implementation, this would use FHE library to encrypt the value
    // For now, we'll use a simple placeholder that returns bytes format
    const valueHex = value.toString(16).padStart(64, '0');
    return '0x' + valueHex;
  };

  // Create vault function with FHE encryption
  const createVault = async (
    nftContract: string,
    nftTokenId: number,
    collateralValue: number,
    requestedLoanAmount: number,
    loanDuration: number
  ) => {
    try {
      setLoading(true);
      setError(null);
      setTransactionStatus('pending');

      // Encrypt values using FHE
      const encryptedNftTokenId = encryptValue(nftTokenId);
      const encryptedCollateralValue = encryptValue(collateralValue);
      const encryptedRequestedAmount = encryptValue(requestedLoanAmount);
      const encryptedLoanDuration = encryptValue(loanDuration);

      // Create input proof (in real implementation, this would be generated by FHE library)
      const inputProof = '0x' + '0'.repeat(64); // Placeholder proof

      const result = await writeContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'createVault',
        args: [
          nftContract,
          encryptedNftTokenId,
          encryptedCollateralValue,
          encryptedRequestedAmount,
          encryptedLoanDuration,
          inputProof
        ],
      });

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create vault');
      setTransactionStatus('error');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Request loan function with FHE encryption
  const requestLoan = async (vaultId: number, requestedAmount: number) => {
    try {
      setLoading(true);
      setError(null);
      setTransactionStatus('pending');

      // Encrypt values using FHE
      const encryptedRequestedAmount = encryptValue(requestedAmount);
      
      // Create input proof
      const inputProof = '0x' + '0'.repeat(64); // Placeholder proof

      const result = await writeContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'requestLoan',
        args: [
          vaultId,
          encryptedRequestedAmount,
          inputProof
        ],
      });

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to request loan');
      setTransactionStatus('error');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Make repayment function with FHE encryption
  const makeRepayment = async (vaultId: number, repaymentAmount: number) => {
    try {
      setLoading(true);
      setError(null);
      setTransactionStatus('pending');

      // Encrypt values using FHE
      const encryptedRepaymentAmount = encryptValue(repaymentAmount);
      
      // Create input proof
      const inputProof = '0x' + '0'.repeat(64); // Placeholder proof

      const result = await writeContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'makeRepayment',
        args: [
          vaultId,
          encryptedRepaymentAmount,
          inputProof
        ],
      });

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to make repayment');
      setTransactionStatus('error');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Liquidate vault function with FHE encryption
  const liquidateVault = async (vaultId: number, liquidationAmount: number) => {
    try {
      setLoading(true);
      setError(null);
      setTransactionStatus('pending');

      // Encrypt values using FHE
      const encryptedLiquidationAmount = encryptValue(liquidationAmount);
      
      // Create input proof
      const inputProof = '0x' + '0'.repeat(64); // Placeholder proof

      const result = await writeContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'liquidateVault',
        args: [
          vaultId,
          encryptedLiquidationAmount,
          inputProof
        ],
      });

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to liquidate vault');
      setTransactionStatus('error');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Approve loan function (for verifiers)
  const approveLoan = async (
    requestId: number,
    vaultId: number,
    approvedAmount: number
  ) => {
    try {
      setLoading(true);
      setError(null);
      setTransactionStatus('pending');

      // Encrypt values using FHE
      const encryptedApprovedAmount = encryptValue(approvedAmount);
      
      // Create input proof
      const inputProof = '0x' + '0'.repeat(64); // Placeholder proof

      const result = await writeContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'approveLoan',
        args: [requestId, vaultId, encryptedApprovedAmount, inputProof],
      });

      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to approve loan');
      setTransactionStatus('error');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Get vault information
  const getVaultInfo = async (vaultId: number): Promise<VaultData | null> => {
    try {
      // Use useReadContract hook for reading contract data
      const { data: result } = useReadContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'getVaultInfo',
        args: [vaultId],
      });

      if (!result) return null;

      return {
        vaultId,
        nftTokenId: result[0] as number,
        collateralValue: result[1] as number,
        loanAmount: result[2] as number,
        interestRate: result[3] as number,
        liquidationThreshold: result[4] as number,
        isActive: result[5] as boolean,
        isLiquidated: result[6] as boolean,
        owner: result[7] as string,
        nftContract: result[8] as string,
        createdAt: Number(result[9]),
        maturityDate: Number(result[10]),
      };
    } catch (err) {
      console.error('Failed to get vault info:', err);
      return null;
    }
  };

  // Get loan request information
  const getLoanRequestInfo = async (requestId: number): Promise<LoanRequestData | null> => {
    try {
      const { data: result } = useReadContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'getLoanRequestInfo',
        args: [requestId],
      });

      if (!result) return null;

      return {
        requestId,
        requestedAmount: result[0] as number,
        nftValue: result[1] as number,
        loanDuration: result[2] as number,
        isApproved: result[3] as boolean,
        isActive: result[4] as boolean,
        borrower: result[5] as string,
        nftContract: result[6] as string,
        nftTokenId: result[7] as number,
        createdAt: Number(result[8]),
      };
    } catch (err) {
      console.error('Failed to get loan request info:', err);
      return null;
    }
  };

  // Get repayment information
  const getRepaymentInfo = async (repaymentId: number): Promise<RepaymentData | null> => {
    try {
      const { data: result } = useReadContract({
        address: VAULT_SHIELD_ADDRESS,
        abi: VaultShieldABI,
        functionName: 'getRepaymentInfo',
        args: [repaymentId],
      });

      if (!result) return null;

      return {
        repaymentId,
        amount: result[0] as number,
        principalAmount: result[1] as number,
        interestAmount: result[2] as number,
        borrower: result[3] as string,
        timestamp: Number(result[4]),
      };
    } catch (err) {
      console.error('Failed to get repayment info:', err);
      return null;
    }
  };

  // Reset transaction status
  const resetTransactionStatus = () => {
    setTransactionStatus('idle');
    setError(null);
  };

  return {
    // Read data
    vaultInfo,
    borrowerReputation,
    totalBorrowed,
    
    // Write functions
    createVault,
    requestLoan,
    makeRepayment,
    liquidateVault,
    approveLoan,
    
    // Read functions
    getVaultInfo,
    getLoanRequestInfo,
    getRepaymentInfo,
    
    // State
    loading,
    error,
    address,
    isConnected,
    transactionStatus,
    hash,
    isPending,
    isConfirming,
    isConfirmed,
    
    // Utility functions
    resetTransactionStatus,
  };
}
